---
title: "Dataplane"
description: "Connect your editor to the WireSocket dataplane, handle regions, and manage reconnection."
---

The WireSocket dataplane is a globally distributed set of WebSocket nodes. This page covers how to connect your editor, handle regions, and manage token renewal and reconnection.

---

## Regions

WireSocket has two region concepts you need to understand:

**License Region** — Set during app creation. Defines where your app's license and plan data is stored. This is the `licenseRegionCode` claim in your JWT. Currently available:

| Code | Location |
|---|---|
| `aws-eu-west-1` | Europe (Ireland) |

**WebSocket Regions** — Where your editors connect for real-time sync. Each region has its own URL:
```
wss://<region>.ws.wiresocket.com
```

Currently available WebSocket regions and their URLs are listed in your [dashboard](https://app.wiresocket.com). More regions (US, APAC) are coming soon.

<Info>
  License Region and WebSocket region are independent. Your license can be stored in EU while your editors connect to a US node.
</Info>

---

## Document Discovery

WireSocket supports two strategies for connecting to the correct regional node for your document:

| Strategy | How | Best For |
|---|---|---|
| **Discovery first** | Call `/discovery`, then connect to returned URL | Lowest latency, zero wrong-region attempts |
| **Connect and catch** | Connect directly, handle `4009 REDIRECT` on error | Fewer HTTP requests, simpler client code |

Both are fully supported. Use Discovery if first-connect latency matters. Use connect-and-catch if you want to avoid the extra HTTP round trip.

### Discovery First
```http
GET https://ws.wiresocket.com/discovery?documentName=your-document-id
Authorization: Bearer YOUR_ACCESS_TOKEN
```

**Response:**
```json
{
  "region": "aws-eu-west-1",
  "url": "wss://eu.ws.wiresocket.com",
  "isNew": false
}
```

| Field | Description |
|---|---|
| `region` | The region currently hosting this document |
| `url` | The WebSocket node URL to connect to |
| `isNew` | `true` if no active session exists — connect to your preferred region |
```js
async function resolveAndConnect(docId, getAccessToken) {
  const token = await getAccessToken()

  // Step 1: Discover the correct node
  const res = await fetch(
    `https://ws.wiresocket.com/discovery?documentName=${docId}`,
    { headers: { Authorization: `Bearer ${token}` } }
  )

  if (!res.ok) {
    // 401 = invalid token, 400 = bad request — stop and check config
    throw new Error(`Discovery failed: ${res.status}`)
  }

  const { url, isNew } = await res.json()

  // Step 2: Resolve the node URL
  // If isNew, no session exists yet — connect to your preferred region
  const nodeUrl = url ?? 'wss://eu.ws.wiresocket.com'

  // Step 3: Connect
  const provider = new WebsocketProvider(
    nodeUrl,
    docId,
    ydoc,
    { protocols: ['Bearer', token] }
  )

  return provider
}
```

<Info>
  If `url` is `null`, the document's region is known but no nodes in that region have sent a heartbeat in the last 2 minutes. Fall back to your default regional URL and retry.
</Info>

<Warning>
  A `401` or `400` response means a configuration problem — invalid token or missing `documentName`. Do not retry automatically. Surface the error to the developer.
</Warning>

### Connect and Catch

If you prefer to skip the HTTP round trip entirely, connect directly to any regional node. If the region is wrong, WireSocket closes the connection with a `4009` code and the correct URL in the close reason — your client catches this and reconnects transparently.
```js
async function connectWithFallback(docId, getAccessToken) {
  const token = await getAccessToken()

  const provider = new WebsocketProvider(
    'wss://eu.ws.wiresocket.com', // connect to any region directly
    docId,
    ydoc,
    { protocols: ['Bearer', token] }
  )

  provider.ws.addEventListener('close', async (event) => {
    if (event.code === 4009 && event.reason.startsWith('REDIRECT:')) {
      const correctUrl = event.reason.replace('REDIRECT:', '')
      const freshToken = await getAccessToken()
      provider.destroy()

      return new WebsocketProvider(
        correctUrl,
        docId,
        ydoc,
        { protocols: ['Bearer', freshToken] }
      )
    }
  })

  return provider
}
```

---

## Document ID Format

Pass any string as your document ID. WireSocket handles isolation internally by prefixing it with `tenantId::appId::` before it reaches the storage layer.

**Recommendations:**
- Keep document IDs under **255 characters**
- Use URL-safe characters — alphanumeric, hyphens, underscores
- Avoid control characters or null bytes
```js
// Good
'my-document-123'
'user_notes_abc'

// Avoid
'doc with spaces'
'doc/with/slashes'
```

---

## Connecting Your Editor

### TipTap
```js
import * as Y from 'yjs'
import { WebsocketProvider } from 'y-websocket'
import { Editor } from '@tiptap/core'
import Collaboration from '@tiptap/extension-collaboration'
import CollaborationCursor from '@tiptap/extension-collaboration-cursor'

const ydoc = new Y.Doc()

const provider = new WebsocketProvider(
  'wss://eu.ws.wiresocket.com',
  'your-document-id',
  ydoc,
  {
    protocols: ['Bearer', 'YOUR_ACCESS_TOKEN']
  }
)

const editor = new Editor({
  extensions: [
    Collaboration.configure({ document: ydoc }),
    CollaborationCursor.configure({ provider }),
  ],
})
```

### y-websocket (framework agnostic)
```js
import * as Y from 'yjs'
import { WebsocketProvider } from 'y-websocket'

const ydoc = new Y.Doc()

const provider = new WebsocketProvider(
  'wss://eu.ws.wiresocket.com',
  'your-document-id',
  ydoc,
  {
    protocols: ['Bearer', 'YOUR_ACCESS_TOKEN']
  }
)

provider.on('status', event => {
  console.log('Connection status:', event.status)
})
```

---

## Passing the Token

Three methods are supported. All work in all regions.

| Method | How |
|---|---|
| WebSocket Subprotocol (recommended) | `protocols: ['Bearer', 'YOUR_ACCESS_TOKEN']` |
| Query Parameter | `wss://eu.ws.wiresocket.com?token=YOUR_ACCESS_TOKEN` |
| Auth Header | `Authorization: Bearer YOUR_ACCESS_TOKEN` |

The subprotocol method is preferred — it keeps the token out of server access logs and browser history.

<Warning>
  The `Origin` header is validated against the `allowed_domains` in your JWT at handshake time. Connections from unlisted domains are rejected before the handshake completes.
</Warning>

---

## Token Expiry & Reconnection

JWT validation happens **at handshake only**. Once connected, an expiring token does not drop an active session. This prevents disruption during live collaboration.

When your token is close to expiry, reconnect with a fresh token:
```js
async function connectWithFreshToken(docId, getAccessToken) {
  const token = await getAccessToken()

  provider.destroy()

  const newProvider = new WebsocketProvider(
    'wss://eu.ws.wiresocket.com',
    docId,
    ydoc,
    { protocols: ['Bearer', token] }
  )

  return newProvider
}
```

<Info>
  Reconnecting re-validates the JWT against the JWKS endpoint and re-reads plan limits from the token claims. This is the correct way to pick up plan changes or credential rotations.
</Info>

**Recommendation:** Set a proactive reconnect timer slightly before token expiry to avoid gaps. For example, reconnect at 13 minutes if your token expires at 15.

---

## Connection Limits

Limits are enforced at handshake. If a limit is reached, the connection is rejected before it is established — no active connections are dropped.

| Limit | Enforcement |
|---|---|
| `maxConnections` | Rejected at handshake if global count is at cap |
| `maxUsersPerDoc` | Rejected at handshake if document user count is at cap |
| `opsPerMinute` | Rate limited during active session |

When a connection is rejected due to limits, handle it gracefully in your editor UI and surface a meaningful message to the user.